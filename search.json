[{"title":"打包体积的分析和优化","url":"/2023/09/01/打包体积的分析和优化/","content":"\n## 工具\n- **Bundle Analyzer Plugin**\n\n## 分析\n通过可视化打包工具发现, 除不太好优化的业务代码包外, 体积较大的是 `vue/dist`、`vue-router/dist` 等一些公共库。\n## 优化\n\n### 1、抽离公共库\n\n#### 具体做法\n\n把项目中的一些公共库提成外部链接, 变成CDN引入, 加载资源时会做相应缓存, 以此达到优化目的。\n\n在构建工具中配置排除对应模块的引入:\n```javascript\n// 示例\n// webpack.config.js\n\nmodule.exports = {\n  externals: {  // 外部依赖, 告诉 Webpaack 不需要引入的模块\n    vue: 'Vue',\n    vuex: 'Vuex',\n    'vue-router': 'VueRouter'\n    // ....\n  }\n}\n```\n\n### 2、针对新老浏览器打包两份\n\n网站用户可以分为两种: 使用**新版本浏览器**的用户和**老版本浏览器**用户。而打包生成的`core.js`文件中包涵一些针对新版本浏览器的兼容性函数补丁, 我们可以将项目打包成两份, 在面向老版本浏览器用户的那一份中删除关于兼容性函数补丁, 以此减小打包体积。\n\n\n\n","tags":["性能优化","Vue"],"categories":["developer"]},{"title":"利用滤镜给图片内容添加阴影","url":"/2023/04/16/利用滤镜给图片内容添加阴影/","content":"\n## 例子\n项目中有个需求要给人物图片添加阴影，我们想当然的会给图片添加 `box-shadow` 属性：\n\n```css\n.person {\n  box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5);\n}\n```\n但是这样真的可行嘛，我们会发现图片变成了这个鬼样子：\n\n![img](https://yunjiemi.com/image/9Mp0D)\n\n显然这不是我们要的效果，于是我们就可以用到 **filter: drop-shadow**  属性。\n\n```css\n.person {\n  filter: drop-shadow(10px 10px 10px rgba(0, 0, 0, 0.5));\n}\n```\n\n![321](https://yunjiemi.com/image/9M9fT)\n\n**filter: drop-shadow** 的作用是对图片像素边缘设置阴影。\n","tags":["CSS3","Filter"],"categories":["developer"]},{"title":"浅谈闭包","url":"/2023/04/14/浅谈闭包/","content":"## 闭包概念\n\n网上关于闭包的概念众说纷纭，这里通过学习总结一下自己关于闭包的理解：\n\n从其表现形式来说闭包其实就是，**在一个函数中返回另一个函数**。换句话说，**闭包可以让你在一个内层函数中访问到其外层函数的作用域**。\n\n我们知道函数被创建时，会在其内部形成一个作用域，函数外部无法访问定义在函数内部的变量。\n\n```javascript\nvar a = 1;\nconsole.log(b);  // 报错\n\nfunction outter() {\n\tvar b = 2;\n    console.log(c);  // 报错\n    \n\tfunction inner() {\n\t\tvar c = 3;\n\t\tconsole.log(a);  // 打印 1\n\t\tconsole.log(b);  // 打印 2\n\t\tconsole.log(c);  // 打印 3\n\t}\n}\n```\n\n当我们试图访问一个变量时，将会最先从当前作用域中查找这个变量，如果找不到，就向上去父级作用域查找，直至最顶层的全局作用域，这些作用域形成的路径就叫**作用域链(Scope chain)**。\n\n## 闭包特性\n\n闭包有如下两个特性：\n\n第一，**闭包是一个函数，而且存在于另一个函数内部。**\n\n第二，**闭包可以访问到外部函数的变量，且该变量不会被销毁。**\n\n```javascript\nfunction outter() {\n    var count = 0;\n    function inner() {\n        count++\n        console.log(count);\n    }\n    return inner;\n}\n\nvar out = outter();\nout();\t// 打印 1\nout();\t// 打印 2\n```\n\n我们定义一个外部函数 `outter`，其中有一个变量 `count` 和一个内部函数 `inner`，在内部函数打印外部函数中的变量 `count`，最后返回内部函数 `inner`。\n\n将 `outter` 运行的结果保存到变量 `out` 中，也就是把内部函数 `inner` 赋值给了 `out`，尽管此时我们实际上运行的是内部函数 `inner`，但是仍旧能访问到外部函数中的变量，这就是利用了作用域链的特性，主动形成了闭包，只要内部函数依赖着外部函数的变量，那么变量就一直会存在，不会 JS 的被垃圾回收机制销毁。\n\n## 闭包作用\n\n**作用一：保护。**\n\n因为闭包会形成私有作用域，因此可以隐藏变量，避免全局污染。适用于模块化开发。\n\n**作用二：保存。**\n\n闭包形成的作用域被外界接收后，会一直存在内存中，不会被销毁，这样就达到了保存数据的目的。但也有了造成内存泄漏的风险。\n","tags":["Javascript","闭包"],"categories":["developer"]},{"title":"入党申请书","url":"/2023/04/07/入党申请书/","content":"\n尊敬的党组织：\n\n我申请加入中国共产党，愿意为党的事业奋斗终身。若能党组织能予以批准，我会自觉拥护党的纲领，遵守党的章程，履行党员义务，严于律己，积极进取，努力做一名优秀的共产党员，为社会主义现代化建设贡献自己的一份力量。\n\n从 1921 年南湖红船会议——党诞生之日起至今，伟大的党已经走过了 102 年光荣而又峥嵘的曲折历程。中国共产党历经沧桑，经历无数的炮火，经历土地革命时的探索，经历抗日战争时的硝烟，经历解放战争的黎明，经历社会主义改造和建设的艰难，经历了2002年非典爆发、2008年汶川地震、2020年新冠疫情......不论天灾还是人祸，在一次次历史性抉择中，中国共产党始终和全国最广大劳动人民紧紧团结在一起，和中国命运的脉搏紧紧相连，最终从势单力薄、星星之火走向如今的繁荣强大、燎原之势。\n\n党的辉煌历史，是为了民族解放和人民幸福英勇奋斗的历史。小时候在学校课本里学习认识了雷锋、焦裕禄、孔繁森、周恩来等等优秀的共产党人，这一个个闪亮的名字好像一盏盏明灯点亮了我昏暗迷茫的精神世界，他们在最平凡的岗位创造了非凡的事迹，为我指引光明的方向，从此，我的心里种下了一颗加入中国共产党的种子。在成长道路的耳濡目染中，中国共产党逐渐在我内心树立起了无法撼动的坚实形象，这些年我国在世界舞台的强势崛起，国家经济的迅猛增长，社会的蓬勃发展和人民生活的改善无不彰显着一条灼灼不变的真理，就是：中国共产党是时代的中流砥柱，是中华名民族的脊梁。\n\n我知道加入中国共产党并没有那么容易，首先思想上要入党。在日常生活中我积极学习党的理论——毛泽东思想、邓小平理论、三个代表重要思想、科学发展观、习近平新时代中国特色社会主义思想，关注国家政治与时事，努力学习科学文化知识，不断提高个人的政治思想觉悟。我发现想要深入了解党的理论，最好的途径就是阅读相关书籍，上大二时，买了第一本人民出版社出版的《共产党宣言》，这是马克思、恩格斯关于全面阐述科学社会主义原理的伟大著作，是科学社会主义的第一个纲领性文献，也是党的初心和使命的思想源头。大学期间反复阅读这本《共产党宣言》，从中我明白了生产力和生产关系之间的矛盾，明白了什么是资产阶级和无产阶级，明白了资本主义社会发展的历史趋势，明白了无产阶级推翻资本主义、实现共产主义的历史使命，也明白了“资产阶级的灭亡和无产阶级的胜利是不可避免的”这一历史发展的客观规律。由此我想到党的初心和使命与《共产党宣言》一脉相承。一百年来，无数共产党人以自己的青春和热血践行着这个历史规律，践行全心全意为人民服务的宗旨，鞠躬尽瘁，谱写了一部感天动地的壮丽史诗，用实际行动昭告党的初心使命。这更加坚定了我想加入中国共产党的决心。\n\n所谓知之愈深、行之愈笃。大学毕业以后，毅然决定参军入伍。在部队生活中，我始终紧紧跟随党的脚步，牢牢团结在党组织的周围，坚决完成党组织交给我的一切任务。刻苦训练，严格要求，提升自我作风，锤炼战斗本领，加强理论学习，每次指导员或者其他政工干部教授理论教育，都会认真听讲，做好笔记。参加党团活动，积极为连队建设献言献策。\n\n两年义务兵中，我利用自身计算机方面的特长，帮助连队、营队和旅队制作 PPT 课件，熬夜加班到凌晨也没有丝毫怨言。当过普通导航干扰员也当过通信员，不管是在班里还是在连部，时刻告诫自己要谦虚谨慎、兢兢业业做好本职工作，站好每一班岗，放好每一班哨，在 2022 年下半年获得优秀四有士兵荣誉和嘉奖。我知道这是连队和党组织对我的认可，并不是值得炫耀的资本。我明白要做一名共产党员，意味着不停的付出和不懈的努力，更明白要做一名真正合格的共产党员，这些远远不够，因为这些都是外在的，要把外在的要求化为生命内在的要求。我清醒地认识到，只有在党组织的激励和指导下，我才能有新的进步，才能充分发挥自己的潜能，为国家、为人民、为社会作出更多更大的贡献。\n\n习主席在党的二十大报告中指出，新时代新征程中国共产党的使命任务就是团结带领全国各族人民全面建成社会主义现代化强国、实现第二个百年奋斗目标，以中国式现代化全面推进中华民族伟大复兴。作为新时代退伍军人、新时代中国青年，更要勇于接过历史的接力棒，勇做时代的奋进者、开拓者、奉献者。当然，我也明白我正处于人生的积累阶段，还有许许多多的缺点和不足，需要像海绵汲水那样汲取知识、阅历，丰富人生经验，增长技能本领，特别是要克服浮躁之气，做到知行合一、以知促行、以行求知，把才干落到实处。我会继续保持一颗谦虚务实的心，在自己的岗位上苦干实干。\n\n都说人生的价值有两种，自我价值与社会价值。自我价值的实现是通过索取，而社会价值的实现则需要贡献。这两种价值对人生的影响力不言而喻，自我价值固然重要，然而社会价值才是能真正衡量人生价值的标准。我渴望实现我的社会价值，希望能够为伟大的祖国、为中国社会主义现代化建设奉献力量，然而个人的力量是有限的，个人的智慧亦如此，因此我需要一个以为人民服务为宗旨的政党来领导我，给我指引前进的方向，这也是我坚定想要加入中国共产党的原因之一。\n\n今日，我正式向党组织递交入党申请书，请党组织在实践中考验我！\n<br>\n\n<div style=\"display: flex; justify-content: space-between; align-items: center;\">\n  <span>​此致<br>​敬礼！</span>\n  <span>申请人：韩俊杰<br>2023年4月7日</span>\n</div>\n","tags":["入党申请书"],"categories":["essay"]},{"title":"封装一个打字机效果的自定义指令","url":"/2023/03/31/封装一个打字机效果的自定义指令/","content":"\n## 前言\n\n在访问 Typora 官网时，对其首页的打字机效果很感兴趣，于是就想在项目中自行封装一个自定义指令，具体效果如下图：\n\n![打字机回退效果](https://b2.kuibu.net/file/imgdisk/2023/04/01/2.gif)\n\n封装后的指令只需要将其绑定在元素上便能使用，那么具体是如何实现的呢？\n\n```html\n<template>\n  <div id=\"Home\">\n    <h1 v-typewriter.loop.underline>这是一段打字机效果文字演示...</h1>\n  </div>\n</template>\n```\n\n## 代码实现\n\n根据演示效果分析，我们可以将其功能分为两部分，一部分是逐字打印文本，另一部分则是光标的闪烁效果。\n\n### 光标\n\n光标我们很容易能想到可以用 CSS 伪元素实现，因为 CSS 中的伪元素 `::after` 是自动跟随在内容末尾的，这符合光标的特性。我们先定义一个类名 `.type-writer`，然后给 `::after` 设为行内块，再给他一个宽高，分别为 `0.1em` 和 `0.5em`，em 是相对于文本的垂直高度的单位，接着设置形变原点为中心，利用 `transform: scaleY(2)` 纵向拉长 2 倍，这就搞定了。\n\n```css\n.type-writer::after {\n  content: \"\";\n  display: inline-block;\n  width: 0.1em;\n  height: 0.5em;\n  transform: scaleY(2);\n  margin-left: 0.1em;\n  margin-bottom: 0.1em;\n}\n```\n\n闪烁效果就更简单了，定义一个名为 blink 的动画：\n\n```css\n.type-writer::after {\n  ...\n  animation: blink 1s infinite;\n}\n\n@keyframes blink {\n  0% {\n    transform: scaleY(2);\n    opacity: 1;\n  }\n  25% {\n    opacity: 0;\n    transform: scaleY(0);\n  }\n  100% {\n    opacity: 1;\n    transform: scaleY(2);\n  }\n}\n```\n\n还有一个问题，就是如何让光标颜色与文本颜色保持一致。我们可以给 `::after` 的 `background-color` 一个变量 `--bg-color`，用来接收文本颜色，在利用 js 获取到文本的颜色属性，赋给这个变量：\n\n```typescript\n/**\n * 光标颜色继承文本颜色\n */\nmounted(el: HTMLElement) {\n  const colorInheritance = () => {\n    const color = getComputedStyle(el).color;\n    el.style.setProperty('--bg-color', color);\n  }\n  colorInheritance();\n}\n\n```\n\n这样光标部分就完成了。根据这个原理我们还可以添加不同类来实现不同的光标样式。\n\n### 打印\n\n那么如何实现打印呢，其实也很简单，无非就是拿到文本内容，然后控制它逐字显示而已：\n\n```typescript\ninterface MyEl extends HTMLElement {\n  oldText: string;\t// 用于保存原来的文本内容\n  isShow: boolea;\n}\ncreated(el: MyEl) {\n  el.oldText = \" \" + el.innerHTML || \"\";\n},\nmounted(el: MyEl) {\n  let count = 0;  // 打印文字计数\n  /**\n   * 打印文字\n   */\n  const typeWriter = () => {\n    if (count < el.oldText.length) {\n      el.innerHTML += el.oldText.charAt(count);\n      count++;\n    } else {\n      el.isShow = true;\n    }\n  }\n}\n```\n\n定义一个接口，`oldText` 用于保存原来的文本内容，在 `created` 钩子中把元素的内容赋值给它。然后创建一个 `count` 变量，在 `typeWriter` 方法中判断 `count` 是否小于文本文字长度，然后显示它。\n\n```typescript\nmounted(el: MyEl) {\n  ...\n\n  el.timer = setInterval(() => {\n    typeWriter();\n  }, speed);\n}\n```\n\n接着创建计时器，在接口中增加 `timer` 属性，把计时器挂载到 `el` 上，这样我们就可以在 `unmounted` 组件卸载时清除计时器，避免造成性能方面的问题，再将计时器的循环时间保存为变量 `speed`，使用指令时就可以通过传参控制打印速度。\n\n```typescript\nimport type { Directive, DirectiveBinding  } from 'vue';\n\ninterface MyEl extends HTMLElement {\n  timer: number;\n  oldText: string;\n}\n\nmounted(el: MyEl, binding: DirectiveBinding) {\n  ...\n\n  const speed = binding.value || 100;  // 获取打印速度\n\n  el.timer = setInterval(() => {\n    typeWriter();\n  }, speed);\n},\nunmounted(el: MyEl) {\n  clearInterval(el.timer);  // 当组件卸载时清除计时器\n}\n```\n\n### 打印回退\n\n还能继续增加一个打印回退的功能，当全部文字都被打印以后，再逐字回退文本。我们只需添加一个回退的方法。\n\n```typescript\nmounted(el: MyEl) {\n  ...\n\n  /**\n   * 回退文字\n   */\n  const typeWriterReduce = () => {\n    if(count > 0) {\n      el.innerHTML = el.oldText.substring(0, count-1);\n      count--;\n    } else {\n      el.isShow = false;\n    }\n  }\n}\n```\n\n根据是否传入修饰符 loop 判断一下是否循环打印。\n\n```typescript\nif (binding.modifiers.loop) {\n  // 判断是否循环打印\n  el.timer = setInterval(() => {\n    let timer = 0;\n    if (el.isShow) {\n      timer = setTimeout(() => {\n        typeWriterReduce();\n      }, 800);\n    } else {\n      clearTimeout(timer);\n      typeWriter();\n    }\n  }, speed);\n} else {\n  el.timer = setInterval(() => {\n    typeWriter();\n  }, speed);\n}\n```\n\n至此，一个打字机指令就完成了。附完整代码：\n\n```typescript\nimport type { Directive, DirectiveBinding } from \"vue\";\n\ninterface MyEl extends HTMLElement {\n  timer: number;\n  oldText: string;\n  isShow: boolean;\n}\n\nconst typeWriter: Directive = {\n  created(el: MyEl, binding: DirectiveBinding) {\n    el.classList.add(\"type-writer\");\n    if (binding.modifiers.underline) {\n      // 判断光标样式\n      el.classList.add(\"type-writer_underline\");\n    } else {\n      el.classList.add(\"type-writer_cursor\");\n    }\n\n    el.oldText = \" \" + el.innerHTML || \"\";\n    el.innerHTML = \"\";\n  },\n  mounted(el: MyEl, binding: DirectiveBinding) {\n    let count = 0; // 打印文字计数\n    const speed = binding.value || 100; // 获取打印速度\n\n    /**\n     * 光标颜色继承文本颜色\n     */\n    const colorInheritance = () => {\n      const color = getComputedStyle(el).color;\n      el.style.setProperty(\"--bg-color\", color);\n    };\n    colorInheritance();\n\n    /**\n     * 打印文字\n     */\n    const typeWriter = () => {\n      if (count < el.oldText.length) {\n        el.innerHTML += el.oldText.charAt(count);\n        count++;\n      } else {\n        el.isShow = true;\n      }\n    };\n\n    /**\n     * 回退文字\n     */\n    const typeWriterReduce = () => {\n      if (count > 0) {\n        el.innerHTML = el.oldText.substring(0, count - 1);\n        count--;\n      } else {\n        el.isShow = false;\n      }\n    };\n\n    if (binding.modifiers.loop) {\n      // 判断是否循环打印\n      el.timer = setInterval(() => {\n        let timer = 0;\n        if (el.isShow) {\n          timer = setTimeout(() => {\n            typeWriterReduce();\n          }, 800);\n        } else {\n          clearTimeout(timer);\n          typeWriter();\n        }\n      }, speed);\n    } else {\n      el.timer = setInterval(() => {\n        typeWriter();\n      }, speed);\n    }\n  },\n  unmounted(el: MyEl) {\n    clearInterval(el.timer); // 当组件卸载时清除计时器\n  },\n};\n\nexport default typeWriter;\n```\n","tags":["Vue3","TypeScript","Directives","打字机"],"categories":["developer"]},{"title":"记录一个关于 Vue3 + Ts 自定义指令的问题","url":"/2023/03/30/记录一个关于-Vue3-Ts-自定义指令的问题/","content":"\n在项目中，尝试封装一个可以实现打字机效果的自定义指令。代码如下\n\n```typescript\nimport type { Directive } from \"vue\";\n\nconst typeWriter: Directive = {\n  created(el: HTMLElement) {\n    el.classList.add(\"type-writer\");\n    const color = getComputedStyle(el).color;\n    el.setAttribute(\"borderColor\", color);\n  },\n  mounted(el: HTMLElement) {\n    const oldText = el.textContent || \"\";\n    const speed = 100;\n    el.textContent = \"\";\n    let count = 0;\n    const typeWriter = () => {\n      if (count < oldText.length) {\n        el.innerHTML += oldText.charAt(count);\n        count++;\n        const timer = setTimeout(typeWriter, speed);\n        this.timer = timer; // 报错：这里的 this 为 undefined\n      }\n    };\n    typeWriter();\n  },\n  unmounted(el: HTMLElement) {\n    clearInterval(el.timer); // 在 unmounted 中清除计时器\n  },\n};\n\nexport default typeWriter;\n```\n\n发现无法获取到 `this`，`this` 的值为 `undefined`。\n\n查询资料后得知，需要先定义一个接口扩展，然后将其作为类型声明给 `el: MyEl`，于是乎在接口中定义的 `timer` 属性便能够通过 `el` 拿到了。修改代码如下：\n\n```typescript\nimport type { Directive } from \"vue\";\n\ninterface MyEl extends HTMLElement {\n  timer: number;\n}\n\nconst typeWriter: Directive = {\n  created(el: MyEl) {\n    el.classList.add(\"type-writer\");\n    const color = getComputedStyle(el).color;\n    el.setAttribute(\"borderColor\", color);\n    console.log(el);\n  },\n  mounted(el: MyEl) {\n    const oldText = el.textContent || \"\";\n    const speed = 100;\n    el.textContent = \"\";\n    let count = 0;\n    const typeWriter = () => {\n      if (count < oldText.length) {\n        el.innerHTML += oldText.charAt(count);\n        count++;\n        const timer = setTimeout(typeWriter, speed);\n        el.timer = timer; // 拿到定时器\n      }\n    };\n    typeWriter();\n  },\n  unmounted(el: MyEl) {\n    clearInterval(el.timer); // 在 unmounted 中清除计时器\n  },\n};\n\nexport default typeWriter;\n```\n","tags":["Vue3","TypeScript","Directives"],"categories":["developer"]},{"title":"初识Pinia","url":"/2023/03/20/初识Pinia/","content":"\n## 前言\n\n最近正在学习 Vue3 相关的技术栈，因此新开了一个商城的项目，在做登录模块时需要保存用户信息，于是习惯性地想到了用 Vuex 来做状态管理。但当我打开 Vue 官网，却发现 Vue 最新文档中，Vuex 不见了，取而代之的是一个叫 **Pinia** 的新的状态管理库。官方称之为：符合直觉的 Vue.js 状态管理库。\n\n好吧，正当我悻悻然以为又是一个需要恶补的新坑时，点开 Pinia 的示例，跟着文档开始安装使用，却发现 Pinia 意外的好用。\n\n## Pinia 的优势\n\n> 据官方的说法，Pinia 的设计理念是简单、轻量、灵活和类型安全。它采用了类似于 React 的原子 hook 的方式，将状态逻辑组织成小的可重用的部分。\n\n### 简单易用\n\nPinia 的 API 设计非常简单易用，不需要像 Vuex 那样掌握一系列的概念和 API。\n我们只需要引入一个`defineStore`方法，然后便可以轻松使用它创建 store。\n\n```javascript\nimport { defineStore } from \"pinia\";\n\n// 你可以对 `defineStore()` 的返回值进行任意命名，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。(比如 `useUserStore`，`useCartStore`，`useProductStore`)\n// 第一个参数是你的应用中 Store 的唯一 ID。\nexport const useAlertsStore = defineStore(\"counter\", {\n  // 其他配置...\n});\n```\n\n而且相比于 Vuex 里繁琐的`mutations`，Pinia 可以直接对`state`进行读写，大大减少了开发的心智负担。\n\n```javascript\nconst store = useStore();\n\nstore.count++;\n```\n\n### 组合式 API\n\nPinia 除了提供类似 Vuex 中选项式 API —— `Option Store`，还提供了另一种定义 store 的语法，即`Setup Store`。\n\n```javascript\nexport const useCounterStore = defineStore(\"counter\", () => {\n  const count = ref(0);\n  function increment() {\n    count.value++;\n  }\n\n  return { count, increment };\n});\n```\n\n在 _Setup Store_ 中：\n\n- `ref()` 就是 `state` 属性\n- `computed()` 就是 `getters`\n- `function()` 就是 `actions`\n\n与 Vue 组合式 API 的 setup 函数相似，我们可以传入一个函数，该函数定义了一些响应式属性和方法，并且返回一个带有我们想暴露出去的属性和方法的对象。\n\n### 多个实例\n\n不同于 Vuex 的单例模式，Pinia 支持多个 store 实例，可以更好地组织和管理复杂的应用程序状态。\n\n### 类型安全\n\nPinia 使用 TypeScript 来增强类型检查，可以避免一些类型相关的错误。\n\n```javascript\nimport { defineStore } from \"pinia\";\n\nconst useStore = defineStore(\"storeId\", {\n  // 为了完整类型推理，推荐使用箭头函数\n  state: () => {\n    return {\n      // 所有这些属性都将自动推断出它们的类型\n      count: 0,\n      name: \"Eduardo\",\n      isAdmin: true,\n      items: [],\n      hasChanged: true,\n    };\n  },\n});\n```\n\n### 支持 SSR\n\nPinia 支持服务端渲染（SSR），可以在服务端和客户端共享相同的状态。\n","tags":["Vuex","Pinia","状态管理"],"categories":["developer"]},{"title":"JavaScript中reduce的用法","url":"/2023/03/19/JavaScript中reduce的用法/","content":"\n## 定义\n`reduce()`：对数组中的每个元素执行回调，并将结果返回。\n`reduce()`：该方法在数组中从左到右工作，与之相对的有 `reduceRight()`。\n\n常可用于数组求和、数组求积、数组去重等等。\n\n## 语法\n```javascript\narr.reduce((prev, cur, index, arr) => {\n...\n}, init)\n```\n\n#### 参数\n参数|可选|描述\n---|---|--|\nprev|必须|累计回调的返回值；表示上一次调用回调时的返回值或初始值 init\ncur|必须|当前正在处理的元素\nindex|可选|当前正在处理的元素索引；若提供init值，则起始索引为0，否则为1\narr|可选|原数组\ninit|可选|第一次执行时的初始值\n\n## 实例\n#### 未设置初始值 `init`\n```javascript\nconst array = [1, 2, 3, 4]\nconst sum = array.reduce((prev, cur, index, arr) => {\n  console.log(prev, cur, index);\n  return prev + cur;\n})\nconsole.log('sum: ', sum);\n\n// 运行结果：\n// 1 2 1\n// 3 3 2\n// 6 4 3\n// sum: 10\n```\nreduce()进行三次迭代，首次迭代中 prev 的值为1，即数组第一项，而后的迭代中 prev 的值是每次回调计算后的值。\n\n#### 设置初始值 `init`\n```javascript\nconst array = [1, 2, 3, 4]\nconst sum = array.reduce((prev, cur, index, arr) => {\n  console.log(prev, cur, index);\n  return prev + cur;\n}, 10)\nconsole.log('sum: ', sum);\n\n// 运行结果：\n// 10 1 0\n// 11 2 1\n// 13 3 2\n// 16 4 3\n// sum: 20\n```\n由此可看出当设置初始值时，首次迭代 prev 即为 init 的值，且 index 初始索引为0。\n\n## reduce()的应用\n#### 数组求和\n#### 计算数组每个元素出现次数\n```javascript\nvar names = ['Xiaoming', 'Wei', 'Xiaohu', 'Xiaohu', 'Gala', 'Wei', 'Letme', 'Xiaohu'];\nvar countNames = names.reduce((prev, cur) => {\n  console.log(prev, cur);\n  if (cur in prev) {\n    prev[cur]++;\n  } else {\n    prev[cur] = 1;\n  }\n  return prev;\n}, {})\nconsole.log(countNames);\n\n// {} 'Xiaoming'\n// {Xiaoming: 1} 'Wei'\n// {Xiaoming: 1, Wei: 1} 'Xiaohu'\n// {Xiaoming: 1, Wei: 1, Xiaohu: 1} 'Xiaohu'\n// {Xiaoming: 1, Wei: 1, Xiaohu: 2} 'Gala'\n// {Xiaoming: 1, Wei: 1, Xiaohu: 2, Gala: 1} 'Wei'\n// {Xiaoming: 1, Wei: 2, Xiaohu: 2, Gala: 1} 'Letme'\n// {Xiaoming: 1, Wei: 2, Xiaohu: 3, Gala: 1, Letme: 1} 'Xiaohu'\n// {Xiaoming: 1, Wei: 2, Xiaohu: 3, Gala: 1, Letme: 1}\n```\n关键在于将初始值设置为空对象`{}`，当首次迭代时判断 prev 中没有 `Xiaoming` 这个属性，因此就将 `Xiaoming` 作为属性名加入空对象，并给其赋值为1；下一次迭代时若遇到重复元素，该属性自加1。\n\n#### 数组元素去重\n🏗 未完待续","tags":["JavaScript","数组方法"],"categories":["developer"]},{"title":"微信小程序之路由","url":"/2023/03/18/微信小程序路由篇/","content":"## 页面栈\n微信小程序中，存在一个页面栈的概念。与 vue-router、react-router 类似：推入一个页面时，该页面会处于栈顶；点击返回时，当前页面出栈。\n\n官方为保证小程序 “小” 的特性，限制了一个路由栈的最大层级为10层，之后则无法推入新的页面。\n\n## 路由跳转API\n- **wx.navigateTo**: 保留当前页面，推入一个新页面\n- **wx.navgateBack**: 关闭当前页面，返回上级页面（当前栈出栈）\n- **wx.redirectTo**: 替换当前页面（当页面栈达到10层无法新增时，往往使用此 API 进行页面跳转）\n- **wx.switchTab**: 负责 tabBar 的切换，在进行切换时，原页面栈会被清空\n- **wx.reLaunch**: 关闭所有页面，推入一个新页面（重启应用）\n\n## 触发页面生命周期\n|路由方式|触发时机|路由前页面生命周期|路由后页面生命周期|\n|---|---|---|---|\n|初始化|小程序打开的第一个页面||`onLoad`|`onLoad` `onShow`|\n|打开新页面调用|wx.navigateTo|`onHide`|`onLoad` `onShow`|\n|页面重定向调用|wx.redirectTo|`onUnload`|`onLoad` `onShow`|\n|页面返回调用|wx.navgateBack|`onUnload`|`onShow`|\n|Tab|wx.switchTab|||\n|重启动|wx.reLaunch|`onUnload`|`onLoad` `onShow`|\n","tags":["小程序"],"categories":["developer"]},{"title":"星河涨落","url":"/2022/05/09/星河涨落/","content":"星河涨落，人事往替。\n\n不随我的意志，也不随谁的意志。\n","tags":["散句"],"categories":["essay"]},{"title":"简单理解MVVM原理","url":"/2020/06/07/简单理解MVVM原理/","content":"> 架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。\n\n## 什么是 MVC 架构\n**MVC，全称 `Model View Controller`，即 `模型-视图-控制器`**，是一种常见的架构模式。\n在Web开发中，通常将前端页面分为上中下三层，分别是：\n* View：视图层。负责 UI 呈现。\n* Controller： 控制层。负责用户交互控制逻辑。从视图接受信息，进行相应逻辑操作，将处理后的信息发送给模型。\n* Model：模型层，又名数据层。负责存储数据信息。\n\n简单来说，Controller 负责将 Model 的数据用 View 显示出来。\n\n优点：MVC 架构实现了模块化，使程序易于维护和扩展，也让程序部分功能复用成为可能。\n\n## 什么是 MVVM 架构\n**MVVM，全称 `Model View ViewModel`**，本质上是 MVC 架构的改进版。\n\n随着业务需求的增加，程序越来越复杂，如果把 View 和 Model 对应的控制关系全部扔到 Controller 中，那么 Controller 将会变得非常庞大臃肿，好像盘互交错的树根。 而 MVVM 架构的出现很好地解决了上述的问题。\n\nMVVM 分离了视图层和数据层 Vie 和 Model 不能直接通信，而必须通过 ViewModel 才能进行交互，当用户操作视图，ViewModel 自动感知变化，然后通知 Model 作出改变数据，而当数据变化时，ViewModel 同样能感知到，并使视图更新，这就是所谓的[双向绑定](https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416)。\n\n优点：MVVM 的响应式架构简化了原本繁琐的dom操作，提高了页面渲染性能。视图和数据自动同步，易于维护复杂变化的数据状态。\n\n","tags":["MVVM"],"categories":["developer"]},{"title":"早年读大刘的《朝闻道》","url":"/2019/11/07/早年读大刘的《朝闻道》/","content":"早年读大刘的《朝闻道》，说物理学家们试图制造创世纪高能粒子加速器来得到宇宙的大统一模型，却被高级文明“排险者”阻止。\n\n为了洞悉宇宙的终极之美，哪怕只有短短一瞬，大批不同领域的顶尖学者们甘愿毁灭自我，前仆后继走向真理祭坛，在换取想要的真理后坦然化作火球湮灭。\n\n任何对我们来说所谓的意义在宇宙的宏观角度来说都没有意义。现实没有排险者出现，我想这也是那么多科学巨擎在晚年迷信神学的原因，遥遥无期的真相可能比任何存在都要黑暗令人绝望。\n\n“朝闻道夕死可以。”\n\n其实就是用天文尺度的庞大格局满足一粒沙的毕生追求。\n","tags":["随记","朝闻道","刘慈欣"],"categories":["essay"]},{"title":"夸你可爱","url":"/2019/02/25/夸你可爱/","content":"夸你可爱，好像骂你怯懦。\n\n所有不合时宜的烂话，终是出于善良。","tags":["散句"],"categories":["essay"]},{"title":"下午回富阳","url":"/2019/02/07/下午回富阳/","content":"\n下午回富阳拿点东西，坐在514上，光线从侧边车窗懒懒地照进来，连月不见的太阳难得出了次全勤。\n\n车厢里意外有些闷热。\n\n菩提寺到富阳公交站正在修地铁，车多路窄，幽灵堵车。车流行的很慢，加上道路坑洼，一路上颠簸不止。\n\n我趴在前座靠椅上，双臂枕着下巴，昏昏沉沉地犯困。\n\n车行至受降，猛得来了个颠簸，屁股不受控制地腾飞，差点没磕掉牙。\n\n司机嘀咕着抱怨，有乘客窃窃私语。\n\n抬起头，车流仍是缓慢。\n","tags":["随记"],"categories":["essay"]},{"title":"硬币掉在地上","url":"/2018/09/21/硬币掉在地上/","content":"硬币掉在了地上，\n\n手机收到催缴话费的短信，\n\n在没人的路上走着，打个嗝。\n\n习惯沉默的人，开听可乐也觉得热闹。\n","tags":["随记"],"categories":["essay"]},{"title":"窗外蝉鸣不绝","url":"/2018/06/29/窗外蝉鸣不绝/","content":"窗外蝉鸣不绝，热夏紧绷绷的空气抑着呼吸。\n\n蓦地醒来，还躺在宿舍的窄床。\n\n胸前摊着那本《寻羊》，手边早已熄了的烟头和半截烟灰把凉席一处烫得发黑。\n\n没滋没味地翻书，或做这夏天该做的梦。\n","tags":["随记","2018年夏"],"categories":["essay"]},{"title":"群山","url":"/2018/06/26/群山/","content":"看那群山轮廓如青花朵朵，\n\n一如理想浓重又脆弱。\n","tags":["散句"],"categories":["essay"]},{"title":"生日快乐","url":"/2018/05/22/生日快乐/","content":"抹香鲸悠然没入云海，\n\n翻涌着温柔的呼吸。\n\n阳光凄美得像是蒲公英的尸体，\n\n把五月消融在可乐倾洒出的阴影。","tags":["散句"],"categories":["essay"]},{"title":"夏是","url":"/2018/04/21/夏是/","content":"夏是啤酒和干锅，\n\n就像孱弱的人沐浴自由的风。","tags":["散句","2018年夏"],"categories":["essay"]},{"title":"窗台外成片荫蔽","url":"/2018/04/10/窗台外成片荫蔽/","content":"窗台外成片荫蔽，\n茂盛的树叶也兜不住的阳光，\n错杂斑驳投落在墙角，\n悄无声息好像牛奶里漂浮的碎面。\n\n海鸥捎回恍如隔世的船讯。\n\n是不是绳子打了结就能拘束这四月的风。\n如果季风有形状，我想大概是孑孓的样子。\n","tags":["随记"],"categories":["essay"]},{"title":"挪威的森林","url":"/2018/04/07/挪威的森林/","content":"从高数课回来，顺路读完了挪威的森林，心里空落落的，怅然若失。想写点什么，又如书中直子回信那样勉强，所有感受如翻腾的云雾，难以表达，非要诉诸语言，只是：\n\n路上阳光很好，身体却觉寒冷。\n\n外卖特意点了寿司，可乐，想象渡边手握着鲷鱼烧，在东京凌晨街头徘徊。\n然而寿司并不好吃，也不管饱。\n\n抽时间看了《挪》电影版，大失所望。\n和想象中的想去甚远。\n直子不是，渡边不是，绿子也不是。\n或许我对记忆里认定的某种东西总是过于苛刻。\n\n对着台灯很久，手机备忘录输入光标一直闪着。睡觉去罢。总之，就这样。\n","tags":["随记","挪威的森林"],"categories":["essay"]}]